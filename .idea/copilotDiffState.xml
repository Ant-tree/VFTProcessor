<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/anttree/vft/processors/VftPlugin.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/anttree/vft/processors/VftPlugin.java" />
              <option name="originalContent" value="package com.anttree.vft.processors;&#10;&#10;import net.bytebuddy.build.Plugin;&#10;import net.bytebuddy.description.annotation.AnnotationDescription;&#10;import net.bytebuddy.description.type.TypeDescription;&#10;import net.bytebuddy.dynamic.ClassFileLocator;&#10;import net.bytebuddy.dynamic.DynamicType;&#10;import net.bytebuddy.description.modifier.Visibility;&#10;import net.bytebuddy.description.method.MethodDescription;&#10;import net.bytebuddy.description.field.FieldDescription;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;&#10;public class VftPlugin implements Plugin {&#10;&#10;    private final String flavor;&#10;    private final String buildType;&#10;    private final String variant;&#10;&#10;    public VftPlugin() {&#10;        this(&quot;&quot;, &quot;&quot;, &quot;&quot;);&#10;    }&#10;&#10;    public VftPlugin(String flavor, String buildType, String variant) {&#10;        this.flavor   = flavor   == null ? &quot;&quot; : flavor.toLowerCase();&#10;        this.buildType= buildType== null ? &quot;&quot; : buildType.toLowerCase();&#10;        this.variant  = variant  == null ? &quot;&quot; : variant.toLowerCase();&#10;&#10;        System.out.println(&quot;VftPlugin initialized with:&quot;);&#10;        System.out.println(&quot;  flavor: &quot; + this.flavor);&#10;        System.out.println(&quot;  buildType: &quot; + this.buildType);&#10;        System.out.println(&quot;  variant: &quot; + this.variant);&#10;    }&#10;&#10;    @Override&#10;    public boolean matches(TypeDescription target) {&#10;        // VisibleForTesting 어노테이션이 있는 클래스만 처리&#10;        try {&#10;            boolean hasAnnotation = target.getDeclaredAnnotations().isAnnotationPresent(VisibleForTesting.class) ||&#10;                   target.getDeclaredMethods().stream().anyMatch(method -&gt;&#10;                       method.getDeclaredAnnotations().isAnnotationPresent(VisibleForTesting.class)) ||&#10;                   target.getDeclaredFields().stream().anyMatch(field -&gt;&#10;                       field.getDeclaredAnnotations().isAnnotationPresent(VisibleForTesting.class));&#10;&#10;            if (hasAnnotation) {&#10;                System.out.println(&quot;VFT: Processing class &quot; + target.getName());&#10;            }&#10;            return hasAnnotation;&#10;        } catch (Exception e) {&#10;            // 어노테이션 확인 중 오류 발생 시 무시&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; b,&#10;                                        TypeDescription td,&#10;                                        ClassFileLocator cfl) {&#10;        try {&#10;            System.out.println(&quot;VFT: Applying transformations to &quot; + td.getName());&#10;&#10;            // 타입 자체의 visibility 변경&#10;            AnnotationDescription vType = td.getDeclaredAnnotations().ofType(VisibleForTesting.class);&#10;            if (vType != null &amp;&amp; shouldApply(getFlavor(vType))) {&#10;                System.out.println(&quot;VFT: Changing class visibility to &quot; + getScope(vType));&#10;                b = b.modifiers(toVisibility(getScope(vType)));&#10;            }&#10;&#10;            // 각 메서드에 대해 개별적으로 처리&#10;            for (MethodDescription method : td.getDeclaredMethods()) {&#10;                AnnotationDescription vMethod = method.getDeclaredAnnotations().ofType(VisibleForTesting.class);&#10;                if (vMethod != null &amp;&amp; shouldApply(getFlavor(vMethod))) {&#10;                    Visibility newVisibility = toVisibility(getScope(vMethod));&#10;                    System.out.println(&quot;VFT: Changing method &quot; + method.getName() + &quot; visibility to &quot; + newVisibility);&#10;&#10;                    // 메서드의 visibility만 변경&#10;                    b = b.method(ElementMatchers.is(method))&#10;                         .intercept(net.bytebuddy.implementation.SuperMethodCall.INSTANCE)&#10;                         .modifiers(newVisibility);&#10;                }&#10;            }&#10;&#10;            // 각 필드에 대해 개별적으로 처리&#10;            for (FieldDescription field : td.getDeclaredFields()) {&#10;                AnnotationDescription vField = field.getDeclaredAnnotations().ofType(VisibleForTesting.class);&#10;                if (vField != null &amp;&amp; shouldApply(getFlavor(vField))) {&#10;                    Visibility newVisibility = toVisibility(getScope(vField));&#10;                    System.out.println(&quot;VFT: Changing field &quot; + field.getName() + &quot; visibility to &quot; + newVisibility);&#10;&#10;                    // 필드의 visibility만 변경&#10;                    b = b.field(ElementMatchers.is(field))&#10;                         .modifiers(newVisibility);&#10;                }&#10;            }&#10;&#10;            return b;&#10;        } catch (Exception e) {&#10;            // 처리 중 오류 발생 시 원본 그대로 반환&#10;            System.err.println(&quot;VFT processing failed for &quot; + td.getName() + &quot;: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            return b;&#10;        }&#10;    }&#10;&#10;    @Override public void close() {}&#10;&#10;    private boolean shouldApply(String annoFlavors) {&#10;        if (annoFlavors == null || annoFlavors.isEmpty()) {&#10;            System.out.println(&quot;VFT: No flavor specified, applying by default&quot;);&#10;            return true; // 기본값으로 적용&#10;        }&#10;&#10;        for (String f : annoFlavors.toLowerCase().replace(&quot; &quot;,&quot;&quot;).split(&quot;,&quot;)) {&#10;            if (f.isEmpty()) continue;&#10;            boolean matches = f.equals(buildType) || f.equals(flavor) || (!variant.isEmpty() &amp;&amp; variant.contains(f));&#10;            System.out.println(&quot;VFT: Checking flavor '&quot; + f + &quot;' against buildType='&quot; + buildType + &quot;', flavor='&quot; + flavor + &quot;', variant='&quot; + variant + &quot;' -&gt; &quot; + matches);&#10;            if (matches) return true;&#10;        }&#10;&#10;        System.out.println(&quot;VFT: No matching flavor found, skipping transformation&quot;);&#10;        return false;&#10;    }&#10;&#10;    private static VisibleForTesting.Scope getScope(AnnotationDescription ann) {&#10;        try {&#10;            return VisibleForTesting.Scope.valueOf(ann.getValue(&quot;scope&quot;).resolve(String.class));&#10;        } catch (Exception e) {&#10;            return VisibleForTesting.Scope.PACKAGE_PRIVATE; // 기본값&#10;        }&#10;    }&#10;&#10;    private static String getFlavor(AnnotationDescription ann) {&#10;        try {&#10;            return ann.getValue(&quot;flavor&quot;).resolve(String.class);&#10;        } catch (Exception e) {&#10;            return &quot;&quot;; // 기본값&#10;        }&#10;    }&#10;&#10;    private static Visibility toVisibility(VisibleForTesting.Scope s) {&#10;        switch (s) {&#10;            case PUBLIC:&#10;                return Visibility.PUBLIC;&#10;            case PROTECTED:&#10;                return Visibility.PROTECTED;&#10;            case PRIVATE:&#10;                return Visibility.PRIVATE;&#10;            default:&#10;                return Visibility.PACKAGE_PRIVATE;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.anttree.vft.processors;&#10;&#10;import net.bytebuddy.build.Plugin;&#10;import net.bytebuddy.description.annotation.AnnotationDescription;&#10;import net.bytebuddy.description.type.TypeDescription;&#10;import net.bytebuddy.dynamic.ClassFileLocator;&#10;import net.bytebuddy.dynamic.DynamicType;&#10;import net.bytebuddy.description.modifier.Visibility;&#10;import net.bytebuddy.description.method.MethodDescription;&#10;import net.bytebuddy.description.field.FieldDescription;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;&#10;public class VftPlugin implements Plugin {&#10;&#10;    private final String flavor;&#10;    private final String buildType;&#10;    private final String variant;&#10;&#10;    public VftPlugin() {&#10;        this(&quot;&quot;, &quot;&quot;, &quot;&quot;);&#10;    }&#10;&#10;    public VftPlugin(String flavor, String buildType, String variant) {&#10;        this.flavor   = flavor   == null ? &quot;&quot; : flavor.toLowerCase();&#10;        this.buildType= buildType== null ? &quot;&quot; : buildType.toLowerCase();&#10;        this.variant  = variant  == null ? &quot;&quot; : variant.toLowerCase();&#10;&#10;        System.out.println(&quot;VftPlugin initialized with:&quot;);&#10;        System.out.println(&quot;  flavor: &quot; + this.flavor);&#10;        System.out.println(&quot;  buildType: &quot; + this.buildType);&#10;        System.out.println(&quot;  variant: &quot; + this.variant);&#10;    }&#10;&#10;    @Override&#10;    public boolean matches(TypeDescription target) {&#10;        // VisibleForTesting 어노테이션이 있는 클래스만 처리&#10;        try {&#10;            boolean hasAnnotation = target.getDeclaredAnnotations().isAnnotationPresent(VisibleForTesting.class) ||&#10;                   target.getDeclaredMethods().stream().anyMatch(method -&gt;&#10;                       method.getDeclaredAnnotations().isAnnotationPresent(VisibleForTesting.class)) ||&#10;                   target.getDeclaredFields().stream().anyMatch(field -&gt;&#10;                       field.getDeclaredAnnotations().isAnnotationPresent(VisibleForTesting.class));&#10;&#10;            if (hasAnnotation) {&#10;                System.out.println(&quot;VFT: Processing class &quot; + target.getName());&#10;            }&#10;            return hasAnnotation;&#10;        } catch (Exception e) {&#10;            // 어노테이션 확인 중 오류 발생 시 무시&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; b,&#10;                                        TypeDescription td,&#10;                                        ClassFileLocator cfl) {&#10;        try {&#10;            System.out.println(&quot;VFT: Applying transformations to &quot; + td.getName());&#10;&#10;            // 타입 자체의 visibility 변경&#10;            AnnotationDescription vType = td.getDeclaredAnnotations().ofType(VisibleForTesting.class);&#10;            if (vType != null &amp;&amp; shouldApply(getFlavor(vType))) {&#10;                System.out.println(&quot;VFT: Changing class visibility to &quot; + getScope(vType));&#10;                b = b.modifiers(toVisibility(getScope(vType)));&#10;            }&#10;&#10;            // 각 메서드에 대해 개별적으로 처리&#10;            for (MethodDescription method : td.getDeclaredMethods()) {&#10;                AnnotationDescription vMethod = method.getDeclaredAnnotations().ofType(VisibleForTesting.class);&#10;                if (vMethod != null &amp;&amp; shouldApply(getFlavor(vMethod))) {&#10;                    Visibility newVisibility = toVisibility(getScope(vMethod));&#10;                    System.out.println(&quot;VFT: Changing method &quot; + method.getName() + &quot; visibility to &quot; + newVisibility);&#10;&#10;                    // 메서드의 visibility만 변경&#10;                    b = b.method(ElementMatchers.is(method))&#10;                         .intercept(net.bytebuddy.implementation.SuperMethodCall.INSTANCE)&#10;                         .modifiers(newVisibility);&#10;                }&#10;            }&#10;&#10;            // 각 필드에 대해 개별적으로 처리&#10;            for (FieldDescription field : td.getDeclaredFields()) {&#10;                AnnotationDescription vField = field.getDeclaredAnnotations().ofType(VisibleForTesting.class);&#10;                if (vField != null &amp;&amp; shouldApply(getFlavor(vField))) {&#10;                    Visibility newVisibility = toVisibility(getScope(vField));&#10;                    System.out.println(&quot;VFT: Changing field &quot; + field.getName() + &quot; visibility to &quot; + newVisibility);&#10;&#10;                    // 필드의 visibility만 변경&#10;                    b = b.field(ElementMatchers.is(field))&#10;                         .modifiers(newVisibility);&#10;                }&#10;            }&#10;&#10;            return b;&#10;        } catch (Exception e) {&#10;            // 처리 중 오류 발생 시 원본 그대로 반환&#10;            System.err.println(&quot;VFT processing failed for &quot; + td.getName() + &quot;: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            return b;&#10;        }&#10;    }&#10;&#10;    @Override public void close() {}&#10;&#10;    private boolean shouldApply(String annoFlavors) {&#10;        if (annoFlavors == null || annoFlavors.isEmpty()) {&#10;            System.out.println(&quot;VFT: No flavor specified, applying by default&quot;);&#10;            return true; // 기본값으로 적용&#10;        }&#10;&#10;        for (String f : annoFlavors.toLowerCase().replace(&quot; &quot;,&quot;&quot;).split(&quot;,&quot;)) {&#10;            if (f.isEmpty()) continue;&#10;            boolean matches = f.equals(buildType) || f.equals(flavor) || (!variant.isEmpty() &amp;&amp; variant.contains(f));&#10;            System.out.println(&quot;VFT: Checking flavor '&quot; + f + &quot;' against buildType='&quot; + buildType + &quot;', flavor='&quot; + flavor + &quot;', variant='&quot; + variant + &quot;' -&gt; &quot; + matches);&#10;            if (matches) return true;&#10;        }&#10;&#10;        System.out.println(&quot;VFT: No matching flavor found, skipping transformation&quot;);&#10;        return false;&#10;    }&#10;&#10;    private static VisibleForTesting.Scope getScope(AnnotationDescription ann) {&#10;        try {&#10;            return VisibleForTesting.Scope.valueOf(ann.getValue(&quot;scope&quot;).resolve(String.class));&#10;        } catch (Exception e) {&#10;            return VisibleForTesting.Scope.PACKAGE_PRIVATE; // 기본값&#10;        }&#10;    }&#10;&#10;    private static String getFlavor(AnnotationDescription ann) {&#10;        try {&#10;            return ann.getValue(&quot;flavor&quot;).resolve(String.class);&#10;        } catch (Exception e) {&#10;            return &quot;&quot;; // 기본값&#10;        }&#10;    }&#10;&#10;    private static Visibility toVisibility(VisibleForTesting.Scope s) {&#10;        switch (s) {&#10;            case PUBLIC:&#10;                return Visibility.PUBLIC;&#10;            case PROTECTED:&#10;                return Visibility.PROTECTED;&#10;            case PRIVATE:&#10;                return Visibility.PRIVATE;&#10;            default:&#10;                return Visibility.PACKAGE_PRIVATE;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>